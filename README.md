#### 1-1 SQL 을 직접 다룰 때 발생하는 문제
###### 정리
    SQL 을 직접 다룰 땐, 객체가 연관된 다른 객체를 사용할 수 있을 지 없을지는 전적으로 사용하는 SQL 에 달려있다.
    SQL 에 모든 것을 의존하는 상황에서는 개발자들이 엔티티를 신뢰하고 사용할 수 없다.
    대신에 DAO 를 열어서 어떤 SQL 이 실행되고 어떤 객체들이 함께 조회되는지 일일이 확인해야 한다.
    SQL 과 JDBC API 를 데이터 접근 계층에 숨기는데 성공했을지는 몰라도 논리적으로는 엔티티와 아주 강항 의존관계를 가지고 있다.
    이런 강한 의존관계 때문에 회원을 조회할 때는 물론이고 회원 객체에 필드를 하나 추가할 때도 DAO 의 CRUD 코드와 SQL 대부분을
    변경해야 하는 문제가 발생한다.
    
    JPA 를 사용하면 객체를 데이터베이스에 저장하고 관리할 때, 개발자가 직접 SQL 을 작성하는 것이 아니라
    JPA 가 제공하는 API 를 사용하면 된다.
    JPA 가 개발자 대신 적절한 SQL 을 생성하여 데이터베이스에 전달한다.
    
    기능 :
        persist( 객체 ); : 데이터베이스에 저장
        find( class명, 아이디 ); : 객체 하나를 조회
        set~ : JPA 는 별도의 수정 메서드를 제공하지 않음, 조회 후 값을 변경하면 커밋할때 자동으로 update 됨
        get~ : 연관된 객체 조회, 메서드를 실행하는 시점에 연관 객체를 조회한다.

#### 1-2 패러다임의 불일치
###### 정리
    애플리케이션은 자바라는 객체지향 언어로 개발하고 데이터는 관계형 데이터베이스에 저장해야 한다면,
    패러다임의 불일치 문제를 개발자가 중간에서 해결해야 한다.
    상속
        JPA 는 상속과 관련된 패러다임의 불일치 문제를 개발자 대신 해결해준다.
        개발자는 마치 자바 컬렉션에 객체를 저장하듯이 JPA 에게 객체를 저장하면 된다.
    연관관계
        객체는 참조를 사용해서 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회한다.
        반면에 테이블은 외래 키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 사용하여 연관된 테이블을 조회한다.
        개발자는 회원과 팀의 관계를 설정하고 회원 객체를 저장하면 된다.
        JPA 는 객체의 참조를 외래 키로 변환해서 적절한 INSERT SQL 을 데이터 베이스에 전달한다.
        객체를 조회할 때 외래 키를 참조로 변환하는 일도 JPA 가 해준다.
    객체 그래프 탐색
        SQL 을 직접 다루면 처음 실행하는 SQL 에 따라 객체 그래프를 어디까지 탑색할 수 있는지 정해진다.
        JPA 는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL 을 실행한다.
        따라서 JPA 를 사용하면 연관된 객체를 신뢰하고 마음껏 조회할 수 있다.
        이 기능은 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룬다고 해서 지연 로딩이라 한다.
    객체 비교
        SQL 로 같은 데이터를 조회하여 객체에 저장한다면
        그 객체는 동등성 ( equals ) 는 갖지만 동일성 ( === ) 은 갖지 못한다.
        JPA 는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다.

#### 1-1
###### 코드 추가
###### gradle 추가
###### 문제점
###### 정리