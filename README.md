#### 1-1 SQL 을 직접 다룰 때 발생하는 문제
###### 정리
    SQL 을 직접 다룰 땐, 객체가 연관된 다른 객체를 사용할 수 있을 지 없을지는 전적으로 사용하는 SQL 에 달려있다.
    SQL 에 모든 것을 의존하는 상황에서는 개발자들이 엔티티를 신뢰하고 사용할 수 없다.
    대신에 DAO 를 열어서 어떤 SQL 이 실행되고 어떤 객체들이 함께 조회되는지 일일이 확인해야 한다.
    SQL 과 JDBC API 를 데이터 접근 계층에 숨기는데 성공했을지는 몰라도 논리적으로는 엔티티와 아주 강항 의존관계를 가지고 있다.
    이런 강한 의존관계 때문에 회원을 조회할 때는 물론이고 회원 객체에 필드를 하나 추가할 때도 DAO 의 CRUD 코드와 SQL 대부분을
    변경해야 하는 문제가 발생한다.
    
    JPA 를 사용하면 객체를 데이터베이스에 저장하고 관리할 때, 개발자가 직접 SQL 을 작성하는 것이 아니라
    JPA 가 제공하는 API 를 사용하면 된다.
    JPA 가 개발자 대신 적절한 SQL 을 생성하여 데이터베이스에 전달한다.
    
    기능 :
        persist( 객체 ); : 데이터베이스에 저장
        find( class명, 아이디 ); : 객체 하나를 조회
        set~ : JPA 는 별도의 수정 메서드를 제공하지 않음, 조회 후 값을 변경하면 커밋할때 자동으로 update 됨
        get~ : 연관된 객체 조회, 메서드를 실행하는 시점에 연관 객체를 조회한다.

#### 1-2 패러다임의 불일치
###### 정리
    애플리케이션은 자바라는 객체지향 언어로 개발하고 데이터는 관계형 데이터베이스에 저장해야 한다면,
    패러다임의 불일치 문제를 개발자가 중간에서 해결해야 한다.
    상속
        JPA 는 상속과 관련된 패러다임의 불일치 문제를 개발자 대신 해결해준다.
        개발자는 마치 자바 컬렉션에 객체를 저장하듯이 JPA 에게 객체를 저장하면 된다.
    연관관계
        객체는 참조를 사용해서 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회한다.
        반면에 테이블은 외래 키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 사용하여 연관된 테이블을 조회한다.
        개발자는 회원과 팀의 관계를 설정하고 회원 객체를 저장하면 된다.
        JPA 는 객체의 참조를 외래 키로 변환해서 적절한 INSERT SQL 을 데이터 베이스에 전달한다.
        객체를 조회할 때 외래 키를 참조로 변환하는 일도 JPA 가 해준다.
    객체 그래프 탐색
        SQL 을 직접 다루면 처음 실행하는 SQL 에 따라 객체 그래프를 어디까지 탑색할 수 있는지 정해진다.
        JPA 는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL 을 실행한다.
        따라서 JPA 를 사용하면 연관된 객체를 신뢰하고 마음껏 조회할 수 있다.
        이 기능은 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룬다고 해서 지연 로딩이라 한다.
    객체 비교
        SQL 로 같은 데이터를 조회하여 객체에 저장한다면
        그 객체는 동등성 ( equals ) 는 갖지만 동일성 ( === ) 은 갖지 못한다.
        JPA 는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다.

#### 1-3 JPA 란 무엇인가?
###### 정리
    ORM ( Object Relational Mapping ) 은 이름 그대로 객체와 관계형 데이터베이스를 매핑한다는 뜻이다.
    객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결해준다.
    객체 측면에서는 정교한 객체 모델링을 할 수 있고 관계형 데이터베이스는 데이터베이스에 맞도록 모델링하면 된다.
    
    JPA 는 자바 ORM 기술에 대한 표준 명세다. 쉽게 이야기해서 인터페이스를 모아둔 것이다.
    JPA 를 사용해야 하는 이유
    생산성
        JPA 를 사용하면 자바 컬렉션에 객체를 저장하듯이 JPA 에게 저장할 객체를 전달하면 된다.
        INSERT SQL 을 작성하고 JDBC API 를 사용하는 지루하고 반복적인 일은 JPA 가 대신 처리해준다.
    유지보수
        엔티티에 필드를 하나만 추가해도 JPA 가 대신 처리해주므로 필드를 추가하거나 삭제해도 수정해야 할 코드가 줄어든다.
    패러다임의 불일치 해결
        JPA 는 상속, 연관관계, 객체 그래프 탐색, 비교하기와 같은 패러다임의 불일치 문제를 해결해준다.
    성능
        JPA 는 애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공한다.
    데이터 접근 추상화와 벤더 독립성
        애플리케이션과 데이터베이스 사이에 추상화된 데이터 접근 계층을 제공해서 애플리케이션이 특정 데이터베이스 기술에 종속되지 않도록 한다. 
        
#### 2 JPA 시작
###### 코드 추가
    1. 데이터베이스 테이블과 매핑할 클래스 Member 생성
    2. 로직을 실행할 JpaMain 클래스
    3. jpa 설정을 담은 META-INF 디렉토리 안 persistence.xml 파일 생성 ( 자동으로 인식 됨 )
###### maven 추가
    // JPA, Hibernate
    <dependency>
        <groupId>org.hibernate</groupId>
        <artifactId>hibernate-entitymanager</artifactId>
        <version>4.3.10.Final</version>
    </dependency>
    // H2 데이터베이스
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <version>1.4.187</version>
    </dependency>
###### 정리
    엔티티 클래스 사용
    @Entity - 해당 클래스는 테이블과 매핑한다고 JPA 에게 알려줌
    @Table - 엔티티 클래스에 매핑할 테이블 정보를 알려줌
    @Id - 엔티티 클래스의 필드를 테이블의 기본 키에 매핑
    @Column - 필드를 컬럼에 매핑
    매핑 정보가 없는 필드는 어노테이션 생략 시 필드명을 사용해서 컬럼명에 매핑
    
    SQL 표준을 지키지 않거나 특정 데이터베이스만의 고유한 기능을 JPA 에서는 방언 ( Dialect ) 이라 함
    하이버네이트를 포함한 대부분의 JPA 구현체들은 이런 문제를 해결하려고 다양한 데이터베이스 방언 클래스를 제공함
    
    엔티티 매니저 설정
    1. 엔티티 매니저 팩토리 생성
        엔티티 설정파일을 읽어 해당 persistenct-unit 을 찾아 객체를 만들고 데이터 베이스 커넥션 풀도 생성하므로
        엔티티 매니저 팩토리를 생성하는 비용은 아주 크다.
        따라서 엔티티 매니저 팩토리는 애플리케이션 전체에서 딱 한 번만 생성하고 공유해서 사용해야 한다.
    2. 엔티티 매니저 생성
    생성된 엔티티 매니저 팩토리에서 엔티티 매니저를 생성한다.
    엔티티 매니저는 엔티티를 데이터베이스에 등록 / 수정 / 삭제 / 조회 할 수 있다.
    엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드 간에 공유하거나 재사용하면 안된다.
    3. 종료
        사용이 끝나면 엔티티 매니저를 종료하고, 애플리케이션이 종료되면 앤티티 매니저 팩토리도 종료해야 한다.
    
    JPA 를 사용하면 항상 트랜잭션 안에서 데이터를 변경해야 한다.
    JPA 는 엔티티의 매핑 정보를 분석해서 SQL 을 만들어 데이터베이스에 전달한다.
    JPA 는 어떤 엔티티가 변경되었는지 추적하는 기능을 가지고 있다.
    엔티티의 값만 변경하면 데이터베이스의 값을 변경한다.
    
    JPA 를 사용하면 애플리케이션 개발자는 엔티티 객체를 중심으로 개발하고 데이터 베이스에 대한 처리는 JPA 에 맡겨야 한다.
    그런데 테이블이 아닌 엔티티 객체를 대상으로 검색하려면 데이터베이스의 모든 데이터를 애플리케이션으로 불러와서
    엔티티 객체로 변경한 다음 검색해야 하는데, 이는 사실상 불가능하다. 애플리케이션이 필요한 데이터만 데이터베이스에서
    불러오려면 결국 검색 조건이 포함된 SQL 을 사용해야 한다.
    JPA 는 JPQL ( Java Persistence Query Language ) 라는 쿼리 언어로 이런 문제를 해결한다.
    SQL 과 SQL 을 추상화 한 JPQL 의 차이점은 JPQL 은 엔티티 객체를 대상으로 SQL 은 데이터베이스 테이블을 대상으로 쿼리하는 것이다.
    
#### 3-1 엔티티 매니저 팩토리와 엔티티 매니저
###### 정리
    엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 되지만,
    엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안 된다.
    
    엔티티 매니저는 데이터 베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다.

#### 1-1
###### 코드 추가
###### maven 추가
###### 문제점
###### 정리